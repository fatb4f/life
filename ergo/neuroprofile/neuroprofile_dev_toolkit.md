# Cognitive–Executive Toolkit for Software Development

## Overview
A structured toolkit built from your neuropsychological profile, optimized for software development, learning, and daily workflow. Organized for quick reference.

---

# 1. Executive Function & Workflow Design

## 1.1 Task Initiation
- Use explicit start triggers for each work session.
- Convert nebulous tasks into concrete, bite-sized steps.
- Apply “First Action Rule”: always define the smallest physical action required.
- Keep a persistent checklist template for new tasks.

## 1.2 Sequencing & Planning
- Use linear workflows instead of spatial/diagrammatic ones.
- Rely on text-based plans, not visual boards.
- Keep project templates for each type of task: coding, debugging, writing, studying.
- Break down large projects into exact steps (verb-oriented, single-action).

## 1.3 Cognitive Load Management
- Apply hard caps on session length (25–40 min).
- Externalize memory for multi-step tasks (notes, logs, comments).
- Use automated tools for repetitive sequences.
- Avoid holding more than 3 items in working memory during problem solving.

---

# 2. Attention Management

## 2.1 Sustained Attention
- Use Pomodoro cycles with enforced breaks.
- Switch to a different modality when vigilance drops (from reading → coding, etc.).
- Apply structured reading protocols: skim → outline → deep read.

## 2.2 Selective Attention
- Use fullscreen or distraction-free modes.
- Keep one-pane editing in Zellij for focus-heavy tasks.
- Disable notifications and time-based pop-ups.

## 2.3 Vigilance Support
- Insert micro-markers inside long tasks ("checkpoint: step 3 done").
- Use auditory cues to maintain engagement.
- Alternate between high-demand and low-demand tasks.

---

# 3. Emotional Regulation in Technical Tasks

## 3.1 Trigger Management
- Predefine a rule: "Pause, document, step out" when frustration spikes.
- Keep a friction log of recurring triggers.
- Insert a decompression step after difficult debugging sessions.

## 3.2 Error Recovery
- Use a structured error-handling procedure template:
  - Problem summary
  - Hypothesis list
  - Repro steps
  - Known constraints
  - Next action
- Maintain calm by converting uncertainty into structure.

---

# 4. Debugging Toolkit

## 4.1 Mental Model Management
- Avoid holding entire architectures in your head.
- Externalize:
  - Data flows
  - State transitions
  - Dependencies
- Use text-based summaries instead of diagrams.

## 4.2 Debugging Steps
- Reproduce the issue with the smallest case.
- Add instrumentation early (logs, assertions, prints).
- Use tree-walking: identify the earliest correct step.
- Document dead ends to avoid loops.

## 4.3 Session Controls
- 20–30 minute debugging sessions.
- Mandatory summary log after each session.
- If blocked 3 cycles in a row, re-scope the problem.

---

# 5. Coding Strategy Toolkit

## 5.1 Architectural Tasks
- Replace system diagrams with structured markdown lists.
- Build architectures verbally ("Component A receives B and outputs C").
- Use scaffolding generators or templates for file structures.

## 5.2 Daily Coding Practice
- Work in short focused bursts.
- Externalize context in a "scratch buffer" before switching tasks.
- Use copilot/AI support for scaffolding repetitive patterns.

## 5.3 Navigation & IDE Setup
- Favor textual, fuzzy-search driven navigation (fzf, ripgrep, helix picker).
- Minimize tabbed/multi-pane visual layouts.
- Use Zellij autolock and single-focus panes.

---

# 6. Learning Strategy Toolkit (Math + C++)

## 6.1 Memory Supports
- Rely on spaced repetition for syntax-heavy material.
- Externalize formulas and reference sheets.
- Use retrieval practice with small increments.

## 6.2 Reading Dense Material
- Chunk readings into 2–5 minute sections.
- Summarize each section verbally.
- Avoid long uninterrupted theory sessions.

## 6.3 Practice Design
- Alternate between conceptual examples and drills.
- Use worked examples first, then varied practice.
- Review mistakes immediately while context is fresh.

---

# 7. Software Project Workflow

## 7.1 Project Templates
- Maintain a standard project skeleton for:
  - C++ modules
  - Zig build setups
  - Shell automations
  - Study modules
- Always begin from a template rather than from scratch.

## 7.2 Documentation
- Maintain per-project scratchpads.
- Keep a running daily log of progress and obstacles.
- Use "state snapshots" before ending any session.

---

# 8. Visuospatial Compensation Toolkit

## 8.1 Non-Visual Representation
- Convert diagrams into:
  - Lists
  - Tables
  - Text narratives
- Use ASCII-based representation where possible.

## 8.2 Coding Alignment
- Avoid tasks requiring mental rotation (graphics, geometry) without strong scaffolding.
- Use tools that auto-generate visual components if needed.

## 8.3 Navigation Simplification
- Flatten folder structures.
- Hide unneeded directories with filters.
- Use consistent naming patterns.

---

# 9. Automation Support Toolkit

## 9.1 Workflow Automation
- Automate repetitive sequences (testing, building, running).
- Wrap complex commands into scripts.
- Use CI/CD to remove manual overhead.

## 9.2 Daily Automation
- Auto-generate summaries, templates, boilerplate.
- Use scripts to restore context after breaks.
- Maintain an automated environment bootstrap.

---

# 10. Attention–Emotion Safety Net

## 10.1 Cognitive Fatigue Monitoring
- Use HRV or physiological cues to detect overload.
- Stop at first signs of declining precision.

## 10.2 Restart Protocol
- When returning after a break:
  - Read scratchpad summary.
  - Identify next step.
  - Do a 2-minute warmup task.

---

# 11. Long-Term Adaptations

## 11.1 Environment
- Minimize visual complexity.
- Strong reliance on command-line workflows.
- Split work into serialized streams.

## 11.2 Skill Development
- Emphasize verbal-based learning paths.
- Reduce dependence on visual–spatial reasoning.
- Strengthen meta-cognitive strategies.

---

# 12. High-Impact Tools & Methods

- Pomodoro cycles
- Checklists and templates
- Fuzzy-search tools (fzf, rg)
- Text-based architecture docs
- Scratchpads for context
- Short debugging cycles
- Retrieval-based learning
- Automated scaffolding
- Structured emotional safety protocols
- Session logs and state snapshots

---

